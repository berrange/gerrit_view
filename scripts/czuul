#!/usr/bin/env python
# -*- coding: utf-8 -*-

# vim: tabstop=4 shiftwidth=4 softtabstop=4

#    Copyright (C) 2013 Yahoo! Inc. All Rights Reserved.
#
#    Licensed under the Apache License, Version 2.0 (the "License"); you may
#    not use this file except in compliance with the License. You may obtain
#    a copy of the License at
#
#         http://www.apache.org/licenses/LICENSE-2.0
#
#    Unless required by applicable law or agreed to in writing, software
#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
#    License for the specific language governing permissions and limitations
#    under the License.

import copy
import errno
import fnmatch
import functools
import logging
import optparse
import os
import shutil
import sys
import tempfile
import thread
import threading

from six.moves import queue

import git
import requests
import six
import urwid

from datetime import (datetime, timedelta)

logging.basicConfig(level=logging.ERROR,
                    format='%(asctime)s %(levelname)s: %(message)s',
                    stream=sys.stderr)
LOG = logging.getLogger(__name__)

### DEFAULT SETTINGS

ZUUL_URL = 'http://zuul.openstack.org/status.json'
ZUUL_FREQ = 30
ZUUL_MIN_FREQ = 5
ALARM_FREQ = 1.0
SCREENS = 3

### GUI CONSTANTS

PALETTE = (
    # General gui usage
    ('body', urwid.DEFAULT, urwid.DEFAULT),
    ('title', urwid.LIGHT_CYAN, urwid.DEFAULT, 'standout'),
    ('clear', urwid.WHITE, urwid.DEFAULT, 'standout'),
    ('author', urwid.DARK_GREEN, urwid.DEFAULT, 'standout'),
    # Time usage
    ('ok', urwid.LIGHT_GREEN, urwid.DEFAULT),
    ('dead', urwid.DARK_RED, urwid.DEFAULT, 'bold,underline'),
    ('slow', urwid.YELLOW, urwid.DEFAULT),
    ('veryslow', urwid.LIGHT_RED, urwid.DEFAULT),
    ('superslow', urwid.LIGHT_MAGENTA, urwid.DEFAULT, 'bold,underline'),
    # Progress bar usage
    ('normal', urwid.WHITE, urwid.DARK_GRAY),
    ('complete', urwid.WHITE, urwid.DARK_BLUE),
    ('smooth', urwid.WHITE, urwid.LIGHT_BLUE),
    # Column usage
    ('selected', urwid.DARK_GRAY, urwid.DEFAULT),
)
QUIT_KEYS = ('q', 'Q', 'esc')
REFRESH_KEYS = ('r', 'R')

# Other constants
GIT_URI_TPL = 'git://git.openstack.org/%(project)s'
REMOTE_URI_TPL = 'https://review.openstack.org/%(project)s'


def select_time_attr(secs):
    secs = max(0, int(secs))
    if secs <= 300:
        return 'ok'
    if secs <= 600:
        return 'slow'
    if secs <= 1800:
        return 'veryslow'
    return 'superslow'


def seconds_left(expiry_date, expires_in_secs):
    now = datetime.now()
    expires_on = expiry_date + timedelta(seconds=max(0, int(expires_in_secs)))
    much_longer = expires_on - now
    if much_longer.seconds <= 0 or expires_on <= now:
        return 0
    return int(much_longer.seconds)


def format_time(secs, mins, only_mins=False):
    if only_mins:
        if mins <= 0.0:
            return "0m"
        else:
            return "%0.1fm" % (mins)
    else:
        if mins <= 0.0:
            return "%ss/0m" % (secs)
        else:
            return "%ss/%0.1fm" % (secs, mins)


def calculate_completion(review):
    jobs_total = 0
    jobs_remaining = 0
    for j in review.get("jobs", []):
        jobs_total += 1
        if get_int_key("remaining_time", j) > 0:
            jobs_remaining += 1
    if not jobs_total:
        return 1.0
    jobs_finished = max(0, jobs_total - jobs_remaining)
    percent_complete = float(jobs_finished) / float(jobs_total)
    if percent_complete > 1.0:
        return 1.0
    if percent_complete < 0:
        return 0.0
    return percent_complete


def decode_millis(millis):
    if millis < 0:
        millis = 0
    secs = millis / 1000
    minutes = secs / 60.0
    return (secs, minutes)


def clone_project(project, code_path):
    # Create a temporary directory, clone there, then attempt to move to the
    # main directory, if the move fails, that's ok, but the initial clone
    # should not.
    tmp_dir = tempfile.mkdtemp()
    try:
        git_uri = GIT_URI_TPL % {'project': project}
        repo_path = os.path.join(tmp_dir, os.path.basename(project))
        os.makedirs(repo_path)
        repo = git.Repo.clone_from(git_uri, repo_path)
        try:
            shutil.move(repo.working_dir, code_path)
        except IOError as e:
            if e.errno != errno.EEXIST:
                raise
        return git.Repo(code_path)
    finally:
        shutil.rmtree(tmp_dir)


def reset_repo(repo):
    origin = repo.remotes.origin
    origin.update()
    origin = repo.remotes.origin
    for ref in origin.refs:
        if ref.remote_head == 'HEAD':
            continue
        repo.create_head(ref.remote_head, ref, force=True)
    repo.head.reference = origin.refs['HEAD']
    repo.head.reset(index=True, working_tree=True)
    repo.git.clean('-x', '-f', '-d')


def get_int_key(k, in_what, default=0):
    try:
        return int(in_what[k])
    except (KeyError, ValueError, TypeError):
        return default


def validate_entry(ok_set, entry):
    if not entry:
        return False
    if len(ok_set) == 0:
        return True
    for pat in ok_set:
        if pat == entry:
            return True
        if fnmatch.fnmatch(entry, pat):
            return True
    return False


def clear_extra_remotes(repo):
    try:
        origin_name = repo.remotes.origin.name
    except AttributeError:
        pass
    else:
        deletions = set()
        for r in repo.remotes:
            if r.name != origin_name:
                deletions.add(r.name)
        for remote_name in deletions:
            LOG.debug("Deleting remote '%s' from repo %s", remote_name, repo)
            try:
                repo.delete_remote(remote_name)
            except Exception:
                pass


def iter_pipelines(data):
    for raw_data in data.get('pipelines', []):
        name = raw_data.get("name", '')
        description = raw_data.get("description", '')
        if not all([name, description]):
            continue
        p = ZuulPipeline(name, description)
        yield (p, raw_data)


def iter_reviews(data):
    for q in data.get('change_queues', []):
        for h in q.get('heads', []):
            for raw_data in h:
                review_id = raw_data.get("id")
                project = raw_data.get("project")
                if not all([review_id, project]):
                    continue
                r = ZuulReview(review_id, project, url=raw_data.get('url'))
                yield (r, raw_data)


class ReviewFinder(threading.Thread):
    def __init__(self, options):
        super(ReviewFinder, self).__init__()
        self.options = options
        self.daemon = True
        self.work = queue.PriorityQueue()
        self.clone_dir = options.clone_dir
        self.processing = None
        self.lock = threading.Lock()
        self.fetched = 0

    def activity(self):
        with self.lock:
            return (self.fetched, self.work.qsize(), self.processing)

    def process(self, r):
        project = r.project
        review_id = six.text_type(r.review_id)
        change_id = r.change_id

        required_inputs = [review_id, project, change_id]
        if not all(required_inputs):
            raise ValueError("Missing one of %s, invalid inputs"
                             % (required_inputs))

        LOG.debug("Fetching details for %s - %s/%s",
                  project, review_id, change_id)
        path_components = project.strip("/").split("/")
        code_path = os.path.join(self.clone_dir, *path_components)
        try:
            base_path = os.path.dirname(code_path)
            if not os.path.isdir(base_path):
                os.makedirs(base_path)
        except IOError as e:
            if e.errno != errno.EEXIST:
                raise
        if not os.path.exists(code_path):
            repo = clone_project(project, code_path)
        else:
            repo = git.Repo(code_path)

        clear_extra_remotes(repo)
        reset_repo(repo)

        remote_uri = REMOTE_URI_TPL % {'project': project}
        remote = repo.create_remote(review_id, remote_uri)
        sub_id = review_id[-2:]
        ref_id = 'refs/changes/%s/%s/%s' % (sub_id, review_id, change_id)

        # The git.remote.fetch method may read in git progress info and
        # interpret it improperly causing an AssertionError. Because the
        # data was fetched properly subsequent fetches don't seem to fail.
        # So try again if an AssertionError is caught.
        try:
            remote.fetch(ref_id)
        except AssertionError:
            remote.fetch(ref_id)
        repo.git.checkout("FETCH_HEAD")

        description = ''
        summary = ''
        if repo.head.object.message:
            description = six.text_type(repo.head.object.message)
            summary = description.splitlines()[0]
        return {
            'summary': summary,
            'description': description,
            'committer': six.text_type(repo.head.object.committer),
            'author': six.text_type(repo.head.object.author),
        }

    def run(self):
        while True:
            with self.lock:
                self.processing = None
            _priority, r = self.work.get(True)
            with self.lock:
                self.processing = r.unique_id
                self.fetched += 1
            try:
                details = self.process(r)
                with r.lock:
                    r.on_details(details)
            except KeyboardInterrupt:
                thread.interrupt_main()
            except ValueError:
                with r.lock:
                    r.state = 'ignored'
            except Exception:
                LOG.exception("Failed processing review: %s", r.unique_id)
                r.state = None


class ZuulWatcher(threading.Thread):
    def __init__(self, options):
        super(ZuulWatcher, self).__init__()
        self.options = options
        self.daemon = True
        self.data = {}
        self.event = threading.Event()
        self.fetches = 0

    def _fetch(self):
        response = None
        try:
            response = requests.get(self.options.server,
                                    timeout=self.options.frequency * 0.66)
            self.fetches += 1
        except requests.RequestException:
            LOG.exception("Failed fetching zuul data from %s",
                          self.options.server)
        return response

    def _process_response(self, response):
        if not response:
            return
        data = response.json()
        if isinstance(data, (dict)):
            data['__fetched_when'] = datetime.now()
            data['__fetch_id'] = self.fetches
            self.data = copy.deepcopy(data)
        else:
            raise TypeError("Expected dict type, got '%s'" % type(data))

    def run(self):
        while True:
            self.event.wait(timeout=self.options.frequency)
            try:
                self._process_response(self._fetch())
            except KeyboardInterrupt:
                thread.interrupt_main()
            except (ValueError, TypeError):
                LOG.exception("Failed extracting and caching zuul data")
            self.event.clear()


class ZuulReview(urwid.Pile):
    def __init__(self, review_id, project, url=None):
        super(ZuulReview, self).__init__([])
        try:
            self.change_id = int(review_id.split(",", 1)[1].strip())
            self.review_id = int(review_id.split(",", 1)[0].strip())
        except (TypeError, IndexError, ValueError):
            self.change_id = None
            self.review_id = review_id
        self.project = project
        self.jobs = {}
        self.progress_bar = urwid.ProgressBar('normal', 'complete',
                                              0.0, 1.0, 'smooth')
        self.progress_bar.set_completion(0.0)
        title_pieces = [("title", review_id)]
        if url:
            title_pieces.append(("body", " @ %s" % (url)))
        title = urwid.Text(title_pieces)
        self.eta_text = urwid.Text([('clear', "ETA")], align='right')
        rows = [
            urwid.Columns([title, (urwid.FIXED, 12, self.eta_text)]),
            self.progress_bar,
        ]
        for item in rows:
            self.contents.append((item, (urwid.WEIGHT, 1)))
        self.state = None
        self.lock = threading.Lock()

    @property
    def unique_id(self):
        pieces = [self.review_id]
        if self.change_id is not None:
            pieces.append(self.change_id)
        return ",".join([six.text_type(s) for s in pieces])

    def on_details(self, details):
        extra_rows = []
        summary = details.get("summary")
        if summary:
            extra_rows.extend([
                urwid.Text([('title', summary)], align='center'),
            ])
        author = details.get("author")
        if author:
            author = "- %s -" % (author)
            extra_rows.extend([
                urwid.Text([('author', author)], align='center'),
            ])
        if extra_rows:
            extra_rows.insert(0, urwid.Divider(u'─'))
            extra_rows.append(urwid.Divider(u'─'))
            extra_pile = urwid.Pile(extra_rows)
            self.contents.insert(0, (extra_pile, (urwid.WEIGHT, 1)))
        self.state = 'detailed'

    def refresh(self, raw_data):
        new_jobs = []
        remaining_millis = []
        failure_count = 0
        for j in raw_data.get("jobs", []):
            if not j.get("name"):
                continue
            job_name = six.text_type(j.get('name'))
            millis = get_int_key("remaining_time", j)
            remaining_millis.append(millis)
            (secs, mins) = decode_millis(millis)
            time_add_on = ""
            if j.get("result") == 'FAILURE' and j.get("voting"):
                time_attr = 'dead'
                time_add_on = "!"
                failure_count += 1
            else:
                time_attr = select_time_attr(secs)
            time_txt = format_time(secs, mins) + time_add_on
            if job_name in self.jobs:
                (name, remaining) = self.jobs[job_name]
                remaining_txt = remaining.original_widget
                remaining_txt.set_text(time_txt)
                remaining.set_attr_map({None: time_attr})
            else:
                remaining_txt = urwid.Text(time_txt, align='right')
                self.jobs[job_name] = [
                    urwid.Text("- %s" % job_name, align='left'),
                    urwid.AttrMap(remaining_txt, time_attr),
                ]
                new_jobs.append(job_name)
        if new_jobs:
            (p_bar, p_bar_options) = self.contents.pop()
            for job_name in sorted(new_jobs):
                (name_txt, time_txt) = self.jobs[job_name]
                rows = [name_txt, (urwid.WEIGHT, 0.333, time_txt)]
                self.contents.append((urwid.Columns(rows), (urwid.WEIGHT, 1)))
            self.contents.append((p_bar, p_bar_options))
        self.progress_bar.set_completion(calculate_completion(raw_data))
        if remaining_millis:
            max_remaining_millis = max(remaining_millis)
        else:
            max_remaining_millis = 0
        (secs, mins) = decode_millis(max_remaining_millis)
        time_txt = format_time(secs, mins, only_mins=True)
        time_markup = [
            ('clear', "ETA ["),
            ('clear', "]"),
        ]
        if failure_count:
            time_attr = 'dead'
            time_txt += "!"
        else:
            time_attr = select_time_attr(secs)
        time_markup.insert(1, (time_attr, time_txt))
        self.eta_text.set_text(time_markup)


class ZuulPipeline(urwid.Pile):
    def __init__(self, name, description):
        super(ZuulPipeline, self).__init__([])
        self.name = six.text_type(name)
        title_pieces = [('clear', self.name.title())]
        self.description = description
        if description:
            description = description[0].lower() + description[1:]
            title_pieces.append(("body", ", %s" % description))
        rows = [
            urwid.Divider(u'─'),
            urwid.Text(title_pieces),
            urwid.Divider(u'─')
        ]
        for h in rows:
            self.contents.append((h, (urwid.WEIGHT, 1)))


class CyclingColumns(urwid.Columns):
    def __init__(self, maker, count):
        super(CyclingColumns, self).__init__([])
        assert int(count) > 0, 'Column count must be > 0'
        self.columns = []
        self.count = int(count)
        self.maker = maker
        self.index = 0
        for _i in range(0, self.count):
            (c, w) = self.maker()
            self.contents.append((w, (urwid.WEIGHT, 1, False)))
            self.columns.append((c, w))
        self.right_arrow = urwid.SolidFill(u"⇢")
        self.right_arrow_on = False
        self.left_arrow = urwid.SolidFill(u"⇠")
        self.left_arrow_on = False

    def clear(self):
        while len(self.columns) > self.count:
            self.columns.pop()
        self.index = 0
        for (c, w) in self.columns:
            while len(c.contents):
                c.contents.pop()
        self._clear_contents()
        self.right_arrow_on = False
        self.left_arrow_on = False
        for i in range(0, self.count):
            w = self.columns[i][1]
            self.contents.append((w, (urwid.WEIGHT, 1, False)))

    def place(self, w, max_rows, max_cols):

        def is_over_size(c, item_rows=0):
            if len(c.contents) == 0:
                return False
            remaining = max_rows - item_rows
            for w, (_f, _height) in c.contents:
                rows = w.rows((max_cols,), c.focus_item == w)
                remaining -= rows
            if remaining <= 0:
                return True
            return False

        w_rows = w.rows((max_cols,), False)
        column = None
        for (c, _w2) in self.columns:
            if is_over_size(c, w_rows):
                continue
            column = c
            break
        if column is None:
            (c, w2) = self.maker()
            self.columns.append((c, w2))
            column = c
        column.contents.append((w, (urwid.PACK, None)))

        if len(self.columns) > len(self.contents) and not self.right_arrow_on:
            self.right_arrow_on = True
            self.contents.append((self.right_arrow, (urwid.GIVEN, 1, False)))

    def _clear_contents(self):
        while len(self.contents):
            self.contents.pop()

    def shift_contents_left(self):
        if (self.index + self.count) == len(self.columns):
            return False
        self.index += 1
        j = self.index
        self._clear_contents()
        for _i in range(0, self.count):
            w = self.columns[j][1]
            self.contents.append((w, (urwid.WEIGHT, 1, False)))
            j += 1
        if self.index > 0:
            self.left_arrow_on = True
        if j == len(self.columns):
            self.right_arrow_on = False
        if self.right_arrow_on:
            self.contents.append((self.right_arrow, (urwid.GIVEN, 1, False)))
        if self.left_arrow_on:
            self.contents.insert(0, (self.left_arrow, (urwid.GIVEN, 1, False)))
        return True

    def shift_contents_right(self):
        if self.index == 0:
            return False
        self.index -= 1
        j = self.index
        self._clear_contents()
        for _i in range(0, self.count):
            w = self.columns[j][1]
            self.contents.append((w, (urwid.WEIGHT, 1, False)))
            j += 1
        if self.index > 0:
            self.right_arrow_on = True
        if self.index == 0:
            self.left_arrow_on = False
        if self.right_arrow_on:
            self.contents.append((self.right_arrow, (urwid.GIVEN, 1, False)))
        if self.left_arrow_on:
            self.contents.insert(0, (self.left_arrow, (urwid.GIVEN, 1, False)))
        return True

    def keypress(self, size, key):
        if key is None:
            return
        if self.focus_position is None:
            return key
        widths = self.column_widths(size)
        if self.focus_position >= len(widths):
            return key
        i = self.focus_position
        mc = widths[i]
        w, (t, n, b) = self.contents[i]
        if len(size) == 1 and b:
            key = w.keypress((mc, self.rows(size, True)), key)
        else:
            key = w.keypress((mc,) + size[1:], key)
        m_key = self._command_map[key]
        if m_key not in (urwid.CURSOR_LEFT, urwid.CURSOR_RIGHT):
            return key
        k = i
        content_len = len(self.contents)
        if self.left_arrow_on:
            k -= 1
            content_len -= 1
        if self.right_arrow_on:
            content_len -= 1
        if k == 0:
            if m_key == urwid.CURSOR_LEFT:
                if self.shift_contents_right():
                    return None
        if k + 1 == content_len:
            if m_key == urwid.CURSOR_RIGHT:
                if self.shift_contents_left():
                    for m in reversed(list(range(0, len(self.contents)))):
                        if not self.contents[m][0].selectable():
                            continue
                        self.focus_position = m
                        break
                    return None
        candidates = []
        if m_key == urwid.CURSOR_RIGHT:
            candidates.extend(range(i + 1, len(self.contents)))
        else:
            candidates.extend(reversed(list(range(0, i))))
        for j in candidates:
            if not self.contents[j][0].selectable():
                continue
            self.focus_position = j
            return None
        return key


class ZuulFrame(urwid.Frame):
    @staticmethod
    def _make_columns(column_count):

        def column_maker():
            c = urwid.Pile([])
            w = urwid.ListBox(urwid.SimpleFocusListWalker([c]))
            w = urwid.AttrWrap(w, 'body')
            w = urwid.AttrMap(urwid.LineBox(w), 'selected', 'body')
            return (c, w)

        return CyclingColumns(column_maker, column_count)

    def __init__(self, options, source):
        self.options = options
        self.source = source
        self.finder = None
        screen_count = options.screens
        assert screen_count > 0, "One or more split-screens must be provided!"
        self.screen_count = screen_count
        self.right_footer = urwid.Text('', align='right')
        self.center_footer = urwid.Text('', align='center')
        self.left_footer = urwid.Text("Initializing...", align='left')
        footer = urwid.AttrWrap(
            urwid.Columns((self.left_footer,
                           self.center_footer, self.right_footer)), 'body')
        self.last_fetched = None
        self.last_fetch_id = None
        self.columns = self._make_columns(screen_count)
        self.last_reviews = {}
        self.allowed_projects = set([p.lower()
                                     for p in self.options.projects if p])
        self.allowed_pipelines = set([p.lower()
                                      for p in self.options.pipelines if p])
        super(ZuulFrame, self).__init__(self.columns, footer=footer)

    def keypress(self, size, key):
        if key in REFRESH_KEYS:
            self.source.event.set()
            return None
        return super(ZuulFrame, self).keypress(size, key)

    def _refresh_pipelines(self, zuul_data, screen_size):

        def fire_finder(r):
            if not self.options.detail:
                return
            with r.lock:
                if r.state in ('detailed', 'detailing', 'ignored'):
                    return
                r.state = 'detailing'
            if self.finder is None:
                self.finder = ReviewFinder(self.options)
                self.finder.start()
            priority = sys.maxint
            try:
                priority = -1 * int(r.review_id)
            except (TypeError, ValueError):
                pass
            self.finder.work.put((priority, r))

        maxcol, maxrow = screen_size
        maxcol = maxcol / self.screen_count
        pipes = {}
        valid_pipeline = functools.partial(validate_entry,
                                           self.allowed_pipelines)
        for (p, raw_data) in iter_pipelines(zuul_data):
            if not valid_pipeline(p.name):
                continue
            pipes[p.name] = {
                'pipeline': p,
                'reviews': [],
                'data': raw_data,
            }

        reviews = {}
        valid_project = functools.partial(validate_entry,
                                          self.allowed_projects)
        for name in sorted(pipes.keys()):
            for (r, raw_data) in iter_reviews(pipes[name]['data']):
                if not valid_project(r.project):
                    continue
                if r.unique_id in self.last_reviews:
                    r = self.last_reviews[r.unique_id]
                try:
                    with r.lock:
                        r.refresh(raw_data)
                except (KeyError, TypeError, ValueError):
                    pass
                else:
                    reviews[r.unique_id] = r
                    pipes[name]['reviews'].append(r)

        def cmp_reviews(r1, r2):
            return cmp((r1.review_id, r1.change_id),
                       (r2.review_id, r2.change_id))

        self.last_reviews = reviews
        self.columns.clear()
        for name in sorted(pipes.keys()):
            self.columns.place(pipes[name]['pipeline'], maxrow, maxcol)
            for r in reversed(sorted(pipes[name]['reviews'], cmp=cmp_reviews)):
                self.columns.place(r, maxrow, maxcol)
        for r in six.itervalues(reviews):
            fire_finder(r)

        fetch_id = zuul_data['__fetch_id']
        detailed = 0
        if self.finder is not None:
            detailed, _queued, _processing = self.finder.activity()
        text = "%s pipelines (%sr, %sw, %sf, %sd)"
        text = text % (len(pipes), len(reviews),
                       len(self.columns.columns), fetch_id, detailed)
        self.right_footer.set_text(text)

    def refresh(self, screen, screen_size):
        if screen_size is None or not all(screen_size):
            return

        zuul_data = dict(self.source.data)
        if not zuul_data:
            self.source.event.set()
            self.left_footer.set_text("Waiting for initial data...")
            return

        def poke(fetched_when):
            much_longer_secs = seconds_left(fetched_when,
                                            self.options.frequency)
            if much_longer_secs <= 0:
                self.source.event.set()

        fetched_when = zuul_data['__fetched_when']
        fetch_id = zuul_data['__fetch_id']
        poke(fetched_when)

        if self.last_fetch_id != fetch_id:
            self._refresh_pipelines(zuul_data, screen_size)
            self.last_fetched = fetched_when
            self.last_fetch_id = fetch_id

        much_longer_secs = seconds_left(self.last_fetched,
                                        self.options.frequency)
        text = "Refresh expected in %s seconds..." % (much_longer_secs)
        self.left_footer.set_text(text)

        detail_text = ''
        if self.finder is not None:
            count = 0
            _fetched, queued, processing = self.finder.activity()
            count += queued
            if processing:
                count += 1
            if count > 0:
                detail_text = "%s reviews waiting to be detailed" % count
                if processing:
                    detail_text += " (processing %s)" % (processing)
        self.center_footer.set_text(detail_text)


def refresh_zuul(loop, frame):
    frame.refresh(loop.screen, loop.screen_size)


def on_unhandled_input(key):
    if key in QUIT_KEYS:
        raise urwid.ExitMainLoop()


def on_idle(loop, frame):
    loop.set_alarm_in(ALARM_FREQ, refresh_zuul, user_data=frame)


def main():
    parser = optparse.OptionParser()
    parser.add_option("-s", "--server", dest="server", action='store',
                      help="zuul server [default: %default]",
                      metavar="URL", default=ZUUL_URL)
    parser.add_option("--split-screens", dest="screens", action='store',
                      help="split screen count [default: %default]",
                      type=int, metavar="SCREENS", default=SCREENS)
    parser.add_option("-p", "--pipeline", dest="pipelines", action='append',
                      help="only show given pipelines reviews",
                      metavar="PIPELINE", default=[])
    parser.add_option("-r", "--refresh", dest="frequency", action='store',
                      type=int,
                      help="refresh every X seconds [default: %default]",
                      metavar="SECONDS", default=ZUUL_FREQ)
    parser.add_option("--project", dest="projects", action='append',
                      help="only show given projects reviews",
                      metavar="PROJECT", default=[])
    parser.add_option("--details", dest="detail", action='store_true',
                      help="fetch each reviews details"
                           " [default: %default]", default=False)
    parser.add_option("--detail-dir", dest="clone_dir", action='store',
                      help="store git checkout locations at"
                           " [default: %default]",
                      default=os.path.join(tempfile.gettempdir(), 'czuul'))
    (options, args) = parser.parse_args()
    if options.frequency < ZUUL_MIN_FREQ:
        parser.error("poll frequency must be greater or equal to %s seconds"
                     " and not %s seconds" % (ZUUL_MIN_FREQ,
                                              options.frequency))

    if options.detail:
        if not os.path.isdir(options.clone_dir):
            os.makedirs(options.clone_dir)
    watcher = ZuulWatcher(options)
    frame = ZuulFrame(options, watcher)
    loop = urwid.MainLoop(frame, PALETTE,
                          handle_mouse=False,
                          unhandled_input=on_unhandled_input)
    watcher.start()
    loop.event_loop.enter_idle(functools.partial(on_idle, loop, frame))
    loop.run()


if __name__ == "__main__":
    main()
