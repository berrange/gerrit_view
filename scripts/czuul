#!/usr/bin/env python
# -*- coding: utf-8 -*-

# vim: tabstop=4 shiftwidth=4 softtabstop=4

#    Copyright (C) 2013 Yahoo! Inc. All Rights Reserved.
#
#    Licensed under the Apache License, Version 2.0 (the "License"); you may
#    not use this file except in compliance with the License. You may obtain
#    a copy of the License at
#
#         http://www.apache.org/licenses/LICENSE-2.0
#
#    Unless required by applicable law or agreed to in writing, software
#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
#    License for the specific language governing permissions and limitations
#    under the License.

import copy
import fnmatch
import functools
import logging
import optparse
import os
import subprocess
import sys
import tempfile
import threading

from six.moves import queue

import requests
import six
import urwid

from datetime import (datetime, timedelta)

logging.basicConfig(level=logging.ERROR,
                    format='%(asctime)s %(levelname)s: %(message)s',
                    stream=sys.stderr)
LOG = logging.getLogger(__name__)

### DEFAULT SETTINGS

ZUUL_URL = 'http://zuul.openstack.org/status.json'
ZUUL_FREQ = 30
ZUUL_MIN_FREQ = 5
ALARM_FREQ = 1.0
SCREENS = 3

### GUI CONSTANTS

PALETTE = (
    # General gui usage
    ('body', urwid.DEFAULT, urwid.DEFAULT),
    ('title', urwid.LIGHT_CYAN, urwid.DEFAULT, 'standout'),
    ('clear', urwid.WHITE, urwid.DEFAULT, 'standout'),
    # Time usage
    ('ok', urwid.LIGHT_GREEN, urwid.DEFAULT),
    ('dead', urwid.DARK_RED, urwid.DEFAULT, 'bold,underline'),
    ('slow', urwid.YELLOW, urwid.DEFAULT),
    ('veryslow', urwid.LIGHT_RED, urwid.DEFAULT),
    ('superslow', urwid.LIGHT_MAGENTA, urwid.DEFAULT, 'bold,underline'),
    # Progress bar usage
    ('normal', urwid.WHITE, urwid.DARK_GRAY),
    ('complete', urwid.WHITE, urwid.DARK_BLUE),
    ('smooth', urwid.WHITE, urwid.LIGHT_BLUE),
    # Column usage
    ('selected', urwid.DARK_GRAY, urwid.DEFAULT),
)
QUIT_KEYS = ('q', 'Q', 'esc')
REFRESH_KEYS = ('r', 'R')

# Other constants
DETAILS_GIT = {
    'summary': "%s",
    'author': "%an",
}


def select_time_attr(secs):
    secs = max(0, int(secs))
    if secs <= 300:
        return 'ok'
    if secs <= 600:
        return 'slow'
    if secs <= 1800:
        return 'veryslow'
    return 'superslow'


def seconds_left(expiry_date, expires_in_secs):
    now = datetime.now()
    expires_on = expiry_date + timedelta(seconds=max(0, int(expires_in_secs)))
    much_longer = expires_on - now
    if much_longer.seconds <= 0 or expires_on <= now:
        return 0
    return int(much_longer.seconds)


def format_time(secs, mins, only_mins=False):
    if only_mins:
        if mins <= 0.0:
            return "0m"
        else:
            return "%0.1fm" % (mins)
    else:
        if mins <= 0.0:
            return "%ss/0m" % (secs)
        else:
            return "%ss/%0.1fm" % (secs, mins)


def calculate_completion(review):
    jobs_total = 0
    jobs_remaining = 0
    for j in review.get("jobs", []):
        jobs_total += 1
        if get_int_key("remaining_time", j) > 0:
            jobs_remaining += 1
    if not jobs_total:
        return 1.0
    jobs_finished = max(0, jobs_total - jobs_remaining)
    percent_complete = float(jobs_finished) / float(jobs_total)
    if percent_complete > 1.0:
        return 1.0
    if percent_complete < 0:
        return 0.0
    return percent_complete


def decode_millis(millis):
    if millis < 0:
        millis = 0
    secs = millis / 1000
    minutes = secs / 60.0
    return (secs, minutes)


def get_int_key(k, in_what, default=0):
    try:
        return int(in_what[k])
    except (KeyError, ValueError, TypeError):
        return default


class ReviewFinder(threading.Thread):
    def __init__(self, options):
        super(ReviewFinder, self).__init__()
        self.options = options
        self.daemon = True
        self.work = queue.Queue()
        self.code_dir = options.detail_dir

    def _process(self, raw_data):
        project = raw_data.get("project")
        review_id = raw_data.get('id')
        change_id = None
        try:
            review_id, change_id = review_id.split(",", 1)
        except ValueError:
            pass
        if not all([review_id, project, change_id]):
            return
        LOG.debug("Fetching details for %s - %s/%s",
                  project, review_id, change_id)
        code_dir = os.path.join(self.code_dir, project.strip("/"))
        if not os.path.isdir(os.path.dirname(code_dir)):
            os.makedirs(os.path.dirname(code_dir))
        if not os.path.exists(code_dir):
            LOG.debug("Cloning %s into %s", project, code_dir)
            cmd = [
                'git', 'clone', '-q',
                'git://git.openstack.org/%s' % (project),
                os.path.basename(project),
            ]
            proc = subprocess.Popen(cmd, cwd=os.path.dirname(code_dir))
            proc.wait()
            if proc.returncode != 0:
                LOG.error("Failed cloning %s to %s", project, code_dir)
                return
        cmd = [
            'git', 'checkout', '-q', 'master',
        ]
        proc = subprocess.Popen(cmd, cwd=code_dir)
        proc.wait()
        if proc.returncode != 0:
            LOG.error("Failed checking out master for %s", project)
            return
        sub_id = review_id[-2:]
        cmd = [
            'git', 'fetch', '-q',
            'https://review.openstack.org/%s' % (project),
            'refs/changes/%s/%s/%s' % (sub_id, review_id, change_id),
        ]
        proc = subprocess.Popen(cmd, cwd=code_dir)
        proc.wait()
        if proc.returncode != 0:
            LOG.error("Failed checking out review for %s/%s",
                      review_id, change_id)
            return
        cmd = [
            'git', 'checkout', '-q', 'FETCH_HEAD',
        ]
        proc = subprocess.Popen(cmd, cwd=code_dir)
        proc.wait()
        if proc.returncode != 0:
            LOG.error("Failed fetching review head for %s/%s",
                      review_id, change_id)
            return
        details = {}
        for (key, format) in six.iteritems(DETAILS_GIT):
            cmd = [
                'git', 'log', '-n1', '--format=' + format,
            ]
            proc = subprocess.Popen(cmd, cwd=code_dir,
                                    stdout=subprocess.PIPE,
                                    stderr=subprocess.PIPE)
            (stdout, stderr) = proc.communicate()
            if proc.returncode == 0:
                details[key] = stdout.strip()
        return details

    def run(self):
        while True:
            (raw_data, ok_cb, reset_cb) = self.work.get(True)
            try:
                details = self._process(raw_data)
                if details:
                    data = copy.deepcopy(raw_data)
                    data.update(details)
                    ok_cb(details)
                else:
                    reset_cb()
            except Exception:
                LOG.exception("Failed processing %s", raw_data)
                reset_cb()


class ZuulWatcher(threading.Thread):
    def __init__(self, options):
        super(ZuulWatcher, self).__init__()
        self.options = options
        self.daemon = True
        self.data = {}
        self.event = threading.Event()
        self._fetches = 0

    def run(self):
        while True:
            self.event.wait(timeout=self.options.frequency)
            response = None
            try:
                response = requests.get(self.options.server,
                                        timeout=self.options.frequency * 0.66)
                self._fetches += 1
            except requests.RequestException:
                LOG.exception("Failed fetching zuul data from %s",
                              self.options.server)
            if response:
                try:
                    data = response.json()
                    if isinstance(data, (dict)):
                        self.data = dict(data)
                        self.data['__fetched_when'] = datetime.now()
                        self.data['__fetch_id'] = self._fetches
                    else:
                        raise TypeError("Expected dict type, got '%s'"
                                        % type(data))
                except (ValueError, TypeError):
                    LOG.exception("Failed extracting/caching zuul data")
            self.event.clear()


class ZuulReview(urwid.Pile):
    def __init__(self, review):
        super(ZuulReview, self).__init__([])
        self.review_id = review['id']
        self.jobs = {}
        self.progress_bar = urwid.ProgressBar('normal', 'complete',
                                              0.0, 1.0, 'smooth')
        self.progress_bar.set_completion(0.0)
        title_pieces = [("title", self.review_id)]
        if review.get("url"):
            title_pieces.append(("body", " @ %s" % (review['url'])))
        self.title = urwid.Text(title_pieces)
        self.eta_text = urwid.Text([('clear', "ETA")], align='right')
        rows = [
            urwid.Columns([self.title, (urwid.FIXED, 12, self.eta_text)]),
            self.progress_bar,
        ]
        self.project = review.get("project")
        for item in rows:
            self.contents.append((item, (urwid.WEIGHT, 1)))
        self.state = None

    def on_details(self, details):
        title_pieces = [("title", self.review_id)]
        if details.get("summary"):
            title_pieces.append(("body", " %s" % details['summary']))
        if details.get("url"):
            title_pieces.append(("body", " @ %s" % (details['url'])))
        LOG.debug("Updating title with %s", title_pieces)
        self.title.set_text(title_pieces)
        self.state = 'detailed'

    def refresh(self, review):
        new_jobs = []
        remaining_millis = []
        failure_count = 0
        for j in review.get("jobs", []):
            if not j.get("name"):
                continue
            j_name = str(j.get('name'))
            millis = get_int_key("remaining_time", j)
            remaining_millis.append(millis)
            (secs, mins) = decode_millis(millis)
            time_add_on = ""
            if j.get("result") == 'FAILURE' and j.get("voting"):
                time_attr = 'dead'
                time_add_on = "!"
                failure_count += 1
            else:
                time_attr = select_time_attr(secs)
            time_txt = format_time(secs, mins) + time_add_on
            if j_name in self.jobs:
                (name, remaining) = self.jobs[j_name]
                remaining_txt = remaining.original_widget
                remaining_txt.set_text(time_txt)
                remaining.set_attr_map({None: time_attr})
            else:
                remaining_txt = urwid.Text(time_txt, align='right')
                self.jobs[j_name] = [
                    urwid.Text("- %s" % j_name, align='left'),
                    urwid.AttrMap(remaining_txt, time_attr),
                ]
                new_jobs.append(j_name)
        if new_jobs:
            (p_bar, p_bar_options) = self.contents.pop()
            for j_name in sorted(new_jobs):
                (name_txt, time_txt) = self.jobs[j_name]
                rows = [name_txt, (urwid.WEIGHT, 0.333, time_txt)]
                self.contents.append((urwid.Columns(rows), (urwid.WEIGHT, 1)))
            self.contents.append((p_bar, p_bar_options))
        self.progress_bar.set_completion(calculate_completion(review))
        if remaining_millis:
            max_remaining_millis = max(remaining_millis)
        else:
            max_remaining_millis = 0
        (secs, mins) = decode_millis(max_remaining_millis)
        time_txt = format_time(secs, mins, only_mins=True)
        time_markup = [
            ('clear', "ETA ["),
            ('clear', "]"),
        ]
        if failure_count:
            time_attr = 'dead'
            time_txt += "!"
        else:
            time_attr = select_time_attr(secs)
        time_markup.insert(1, (time_attr, time_txt))
        self.eta_text.set_text(time_markup)


class ZuulPipelineHeader(urwid.Pile):
    def __init__(self, name, description=''):
        super(ZuulPipelineHeader, self).__init__([])
        self.name = str(name)
        title_pieces = [('clear', self.name.title())]
        if description:
            description = description[0].lower() + description[1:]
            title_pieces.append(("body", ", %s" % description))
        rows = [
            urwid.Divider(u'─'),
            urwid.Text(title_pieces),
            urwid.Divider(u'─')
        ]
        for h in rows:
            self.contents.append((h, (urwid.WEIGHT, 1)))
        self.name = name


class CyclingColumns(urwid.Columns):
    def __init__(self, maker, count):
        super(CyclingColumns, self).__init__([])
        assert int(count) > 0, 'Column count must be > 0'
        self.columns = []
        self.count = int(count)
        self.maker = maker
        self.index = 0
        for _i in range(0, self.count):
            (c, w) = self.maker()
            self.contents.append((w, (urwid.WEIGHT, 1, False)))
            self.columns.append((c, w))
        self.right_arrow = urwid.SolidFill(u"⇢")
        self.right_arrow_on = False
        self.left_arrow = urwid.SolidFill(u"⇠")
        self.left_arrow_on = False

    def clear(self):
        while len(self.columns) > self.count:
            self.columns.pop()
        self.index = 0
        for (c, w) in self.columns:
            while len(c.contents):
                c.contents.pop()
        self._clear_contents()
        self.right_arrow_on = False
        self.left_arrow_on = False
        for i in range(0, self.count):
            w = self.columns[i][1]
            self.contents.append((w, (urwid.WEIGHT, 1, False)))

    def place(self, w, max_rows, max_cols):

        def is_over_size(c, item_rows=0):
            if len(c.contents) == 0:
                return False
            remaining = max_rows - item_rows
            for w, (_f, _height) in c.contents:
                rows = w.rows((max_cols,), c.focus_item == w)
                remaining -= rows
            if remaining <= 0:
                return True
            return False

        w_rows = w.rows((max_cols,), False)
        column = None
        for (c, _w2) in self.columns:
            if is_over_size(c, w_rows):
                continue
            column = c
            break
        if column is None:
            (c, w2) = self.maker()
            self.columns.append((c, w2))
            column = c
        column.contents.append((w, (urwid.PACK, None)))

        if len(self.columns) > len(self.contents) and not self.right_arrow_on:
            self.right_arrow_on = True
            self.contents.append((self.right_arrow, (urwid.GIVEN, 1, False)))

    def _clear_contents(self):
        while len(self.contents):
            self.contents.pop()

    def shift_contents_left(self):
        if (self.index + self.count) == len(self.columns):
            return False
        self.index += 1
        j = self.index
        self._clear_contents()
        for _i in range(0, self.count):
            w = self.columns[j][1]
            self.contents.append((w, (urwid.WEIGHT, 1, False)))
            j += 1
        if self.index > 0:
            self.left_arrow_on = True
        if j == len(self.columns):
            self.right_arrow_on = False
        if self.right_arrow_on:
            self.contents.append((self.right_arrow, (urwid.GIVEN, 1, False)))
        if self.left_arrow_on:
            self.contents.insert(0, (self.left_arrow, (urwid.GIVEN, 1, False)))
        return True

    def shift_contents_right(self):
        if self.index == 0:
            return False
        self.index -= 1
        j = self.index
        self._clear_contents()
        for _i in range(0, self.count):
            w = self.columns[j][1]
            self.contents.append((w, (urwid.WEIGHT, 1, False)))
            j += 1
        if self.index > 0:
            self.right_arrow_on = True
        if self.index == 0:
            self.left_arrow_on = False
        if self.right_arrow_on:
            self.contents.append((self.right_arrow, (urwid.GIVEN, 1, False)))
        if self.left_arrow_on:
            self.contents.insert(0, (self.left_arrow, (urwid.GIVEN, 1, False)))
        return True

    def keypress(self, size, key):
        if key is None:
            return
        if self.focus_position is None:
            return key
        widths = self.column_widths(size)
        if self.focus_position >= len(widths):
            return key
        i = self.focus_position
        mc = widths[i]
        w, (t, n, b) = self.contents[i]
        if len(size) == 1 and b:
            key = w.keypress((mc, self.rows(size, True)), key)
        else:
            key = w.keypress((mc,) + size[1:], key)
        m_key = self._command_map[key]
        if m_key not in (urwid.CURSOR_LEFT, urwid.CURSOR_RIGHT):
            return key
        k = i
        content_len = len(self.contents)
        if self.left_arrow_on:
            k -= 1
            content_len -= 1
        if self.right_arrow_on:
            content_len -= 1
        if k == 0:
            if m_key == urwid.CURSOR_LEFT:
                if self.shift_contents_right():
                    return None
        if k + 1 == content_len:
            if m_key == urwid.CURSOR_RIGHT:
                if self.shift_contents_left():
                    for m in reversed(list(range(0, len(self.contents)))):
                        if not self.contents[m][0].selectable():
                            continue
                        self.focus_position = m
                        break
                    return None
        candidates = []
        if m_key == urwid.CURSOR_RIGHT:
            candidates.extend(range(i + 1, len(self.contents)))
        else:
            candidates.extend(reversed(list(range(0, i))))
        for j in candidates:
            if not self.contents[j][0].selectable():
                continue
            self.focus_position = j
            return None
        return key


class ZuulFrame(urwid.Frame):
    @staticmethod
    def _make_columns(column_count):

        def column_maker():
            c = urwid.Pile([])
            w = urwid.ListBox(urwid.SimpleFocusListWalker([c]))
            w = urwid.AttrWrap(w, 'body')
            w = urwid.AttrMap(urwid.LineBox(w), 'selected', 'body')
            return (c, w)

        return CyclingColumns(column_maker, column_count)

    def __init__(self, options, source):
        self.options = options
        self.source = source
        self.finders = {}
        screen_count = options.screens
        assert screen_count > 0, "One or more split-screens must be provided!"
        self.screen_count = screen_count
        self.right_footer = urwid.Text('', align='right')
        self.center_footer = urwid.Text('', align='center')
        self.left_footer = urwid.Text("Initializing...", align='left')
        footer = urwid.AttrWrap(
            urwid.Columns((self.left_footer,
                           self.center_footer, self.right_footer)), 'body')
        self.last_fetched = None
        self.last_fetch_id = None
        self.columns = self._make_columns(screen_count)
        self.last_reviews = {}
        super(ZuulFrame, self).__init__(self.columns, footer=footer)

    def keypress(self, size, key):
        if key in REFRESH_KEYS:
            self.source.event.set()
            return None
        return super(ZuulFrame, self).keypress(size, key)

    def _valid_entry(self, ok_set, entry):
        if not entry:
            return False
        if len(ok_set) == 0:
            return True
        for pat in ok_set:
            if pat == entry:
                return True
            if fnmatch.fnmatch(entry, pat):
                return True
        return False

    def _refresh_pipelines(self, zuul_data, screen_size):
        maxcol, maxrow = screen_size
        maxcol = maxcol / self.screen_count

        pipes = {}
        ok_pipelines = set([p.lower() for p in self.options.pipelines])
        valid_pipeline = functools.partial(self._valid_entry, ok_pipelines)
        for p in zuul_data.get('pipelines', []):
            pipe_name = str(p.get('name', ''))
            if not valid_pipeline(pipe_name):
                continue
            pipes[pipe_name] = str(p.get("description", "")).strip()

        def iter_pipeline(data):
            for q in data.get('change_queues', []):
                for h in q.get('heads', []):
                    for raw_data in h:
                        if not raw_data.get("id"):
                            continue
                        try:
                            r = ZuulReview(raw_data)
                            yield (r, raw_data)
                        except (KeyError, TypeError):
                            pass

        def state_reset(r):
            r.state = None

        def fire_finder(r, raw_data):
            if r.state in ['detailed', 'detailing']:
                return
            if r.project not in self.finders:
                LOG.debug("Creating finder for project %s", r.project)
                finder = ReviewFinder(self.options)
                self.finders[r.project] = finder
                finder.start()
            r.state = 'detailing'
            work_item = [
                raw_data,
                r.on_details,
                functools.partial(state_reset, r),
            ]
            self.finders[r.project].work.put(work_item)

        reviews = {}
        cleaned_pipes = {}
        ordered_pipes = sorted(pipes.keys())
        ok_projects = set([p.lower() for p in self.options.projects])
        valid_project = functools.partial(self._valid_entry, ok_projects)
        for name in ordered_pipes:
            cleaned_pipes[name] = {
                'pipeline': ZuulPipelineHeader(name, pipes[name]),
                'reviews': [],
            }
            for p in zuul_data.get('pipelines', []):
                if p.get('name') == name:
                    for (r, raw_data) in iter_pipeline(p):
                        if not valid_project(r.project):
                            continue
                        if r.review_id in self.last_reviews:
                            r = self.last_reviews[r.review_id]
                        try:
                            r.refresh(raw_data)
                            reviews[r.review_id] = r
                            if self.options.detail:
                                fire_finder(r, raw_data)
                            cleaned_pipes[name]['reviews'].append(r.review_id)
                        except (KeyError, TypeError):
                            pass

        def cmp_reviews(r1, r2):
            try:
                r1_i = int(r1.split(",", 1)[0])
                r2_i = int(r2.split(",", 1)[0])
                return cmp(r1_i, r2_i)
            except (ValueError, TypeError):
                return cmp(r1, r2)

        self.last_reviews = reviews
        self.columns.clear()
        for name in ordered_pipes:
            pipeline = cleaned_pipes[name]['pipeline']
            self.columns.place(pipeline, maxrow, maxcol)
            ids = sorted(cleaned_pipes[name]['reviews'], cmp=cmp_reviews)
            for review_id in reversed(ids):
                self.columns.place(reviews[review_id], maxrow, maxcol)

        # Update right footer text
        fetch_id = zuul_data['__fetch_id']
        text = "%s pipelines (%sr, %sw, %sf)"
        text = text % (len(cleaned_pipes), len(reviews),
                       len(self.columns.columns), fetch_id)
        self.right_footer.set_text(text)

    def refresh(self, screen, screen_size):
        if screen_size is None or not all(screen_size):
            return

        zuul_data = dict(self.source.data)
        if not zuul_data:
            self.source.event.set()
            self.left_footer.set_text("Waiting for initial data...")
            return

        def poke(fetched_when):
            much_longer_secs = seconds_left(fetched_when,
                                            self.options.frequency)
            if much_longer_secs <= 0:
                self.source.event.set()

        fetched_when = zuul_data['__fetched_when']
        fetch_id = zuul_data['__fetch_id']
        poke(fetched_when)

        if self.last_fetch_id != fetch_id:
            self._refresh_pipelines(zuul_data, screen_size)
            self.last_fetched = fetched_when
            self.last_fetch_id = fetch_id

        # Update left footer text
        much_longer_secs = seconds_left(self.last_fetched,
                                        self.options.frequency)
        text = "Refresh expected in %s seconds..." % (much_longer_secs)
        self.left_footer.set_text(text)

        if self.options.detail:
            work_am = 0
            for (_project, finder) in six.iteritems(self.finders):
                work_am += finder.work.qsize()
            if work_am == 0:
                text = ''
            else:
                text = "%s reviews queued to be detailed" % work_am
            self.center_footer.set_text(text)


def refresh_zuul(loop, frame):
    frame.refresh(loop.screen, loop.screen_size)


def on_unhandled_input(key):
    if key in QUIT_KEYS:
        raise urwid.ExitMainLoop()


def on_idle(loop, frame):
    loop.set_alarm_in(ALARM_FREQ, refresh_zuul, user_data=frame)


def main():
    parser = optparse.OptionParser()
    parser.add_option("-s", "--server", dest="server", action='store',
                      help="zuul server [default: %default]",
                      metavar="URL", default=ZUUL_URL)
    parser.add_option("--split-screens", dest="screens", action='store',
                      help="split screen count [default: %default]",
                      type=int, metavar="SCREENS", default=SCREENS)
    parser.add_option("-p", "--pipeline", dest="pipelines", action='append',
                      help="only show given pipelines reviews",
                      metavar="PIPELINE", default=[])
    parser.add_option("-r", "--refresh", dest="frequency", action='store',
                      type=int,
                      help="refresh every X seconds [default: %default]",
                      metavar="SECONDS", default=ZUUL_FREQ)
    parser.add_option("--project", dest="projects", action='append',
                      help="only show given projects reviews",
                      metavar="PROJECT", default=[])
    parser.add_option("--details", dest="detail", action='store_true',
                      help="fetch each reviews details"
                           " [default: %default]", default=False)
    parser.add_option("--detail-dir", dest="detail_dir", action='store',
                      help="store git checkout locations at"
                           " [default: %default]",
                      default=os.path.join(tempfile.gettempdir(), 'czuul'))
    (options, args) = parser.parse_args()
    if options.frequency < ZUUL_MIN_FREQ:
        parser.error("poll frequency must be greater or equal to %s seconds"
                     " and not %s seconds" % (ZUUL_MIN_FREQ,
                                              options.frequency))

    if options.detail:
        if not os.path.isdir(options.detail_dir):
            os.makedirs(options.detail_dir)
    watcher = ZuulWatcher(options)
    frame = ZuulFrame(options, watcher)
    loop = urwid.MainLoop(frame, PALETTE,
                          handle_mouse=False,
                          unhandled_input=on_unhandled_input)
    watcher.start()
    loop.event_loop.enter_idle(functools.partial(on_idle, loop, frame))
    loop.run()


if __name__ == "__main__":
    main()
